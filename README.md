1. html from auto corruption vs. html generated by gpt-4
pros: 
    a. more controllable
    b. easier to get training data (i.e., ground truth action sequence can be derived from the corruption path)
    c. easier to evaluate (related to b, but not exactly the same)
    d. more manageable for existing MLLMs
cons:
    a. (maybe) less diversity

2. using screenshots vs. using wireframes
pros:
    a. screenshots are more accurate and less noisy (our wireframes generated by uizard is not error-free, while accuracy is critical for our evaluation here)
    b. (optional) allows us to use the difference between two screenshots as nvironmental feedback
cons:
    N/A; but wireframes can be an additional option

3. using screenshots vs. using requirements
pros:
    a. strictly requires more multimodal capacity
    b. unlike the requirements we got previously, the requirements specified for adjustments can be challenging to get (in particular fine-grained requirements)
    c. screenshots are less ambiguous, which allows for more strict evaluation
cons:
    N/A

4. practical?
There is a type of testing called visual regression testing in frontend development, which might be similar to our setting.
(https://david-x.medium.com/the-state-of-visual-regression-testing-in-2022-5de10ffe8f6f)
Also, we can say we are mimicing humans' behavior in adjusting their html code.

5. sequential planning?
There are two dimensions: a. whether the task **can only be** modeled as a sequential planning problem, and b. whether the task **can be** approached as sequential planning.
The answer to both questions are yes for our GUI and embodied AI tasks, while the answer to the first question is no for our visual design task, but this does not mean the outcome of previous action is irrelevant to the next action for the visual design agent.

6. why use a fixed action space? why not ask the agent to output an html or a patch file like in SWE-Bench?
    a. To align more with other tasks, which is important for training
    b. Ideally, this puts better regularization on the agent's behavior and might lead to better performance# WebDreamer
